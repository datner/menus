# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCateogry {
  _avg: CateogryAvgAggregate
  _count: CateogryCountAggregate
  _max: CateogryMaxAggregate
  _min: CateogryMinAggregate
  _sum: CateogrySumAggregate
}

type AggregateCateogryI18L {
  _avg: CateogryI18LAvgAggregate
  _count: CateogryI18LCountAggregate
  _max: CateogryI18LMaxAggregate
  _min: CateogryI18LMinAggregate
  _sum: CateogryI18LSumAggregate
}

type AggregateItem {
  _avg: ItemAvgAggregate
  _count: ItemCountAggregate
  _max: ItemMaxAggregate
  _min: ItemMinAggregate
  _sum: ItemSumAggregate
}

type AggregateItemI18L {
  _avg: ItemI18LAvgAggregate
  _count: ItemI18LCountAggregate
  _max: ItemI18LMaxAggregate
  _min: ItemI18LMinAggregate
  _sum: ItemI18LSumAggregate
}

type AggregateMenu {
  _avg: MenuAvgAggregate
  _count: MenuCountAggregate
  _max: MenuMaxAggregate
  _min: MenuMinAggregate
  _sum: MenuSumAggregate
}

type AggregateOrder {
  _avg: OrderAvgAggregate
  _count: OrderCountAggregate
  _max: OrderMaxAggregate
  _min: OrderMinAggregate
  _sum: OrderSumAggregate
}

type AggregateRestaurant {
  _avg: RestaurantAvgAggregate
  _count: RestaurantCountAggregate
  _max: RestaurantMaxAggregate
  _min: RestaurantMinAggregate
  _sum: RestaurantSumAggregate
}

type AggregateRestaurantI18L {
  _avg: RestaurantI18LAvgAggregate
  _count: RestaurantI18LCountAggregate
  _max: RestaurantI18LMaxAggregate
  _min: RestaurantI18LMinAggregate
  _sum: RestaurantI18LSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type Cateogry {
  _count: CateogryCount
  content(cursor: CateogryI18LWhereUniqueInput, distinct: [CateogryI18LScalarFieldEnum!], orderBy: [CateogryI18LOrderByWithRelationInput!], skip: Int, take: Int, where: CateogryI18LWhereInput): [CateogryI18L!]!
  createdAt: DateTime!
  id: Int!
  identifier: String!
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  menu: Menu!
  menuId: Int!
  updatedAt: DateTime!
}

type CateogryAvgAggregate {
  id: Float
  menuId: Float
}

input CateogryAvgOrderByAggregateInput {
  id: SortOrder
  menuId: SortOrder
}

type CateogryCount {
  content: Int!
  items: Int!
}

type CateogryCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  identifier: Int!
  menuId: Int!
  updatedAt: Int!
}

input CateogryCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  menuId: SortOrder
  updatedAt: SortOrder
}

input CateogryCreateInput {
  content: CateogryI18LCreateNestedManyWithoutCategoryInput
  createdAt: DateTime
  identifier: String!
  items: ItemCreateNestedManyWithoutCategoryInput
  menu: MenuCreateNestedOneWithoutCategoriesInput!
  updatedAt: DateTime
}

input CateogryCreateManyInput {
  createdAt: DateTime
  id: Int
  identifier: String!
  menuId: Int!
  updatedAt: DateTime
}

input CateogryCreateManyMenuInput {
  createdAt: DateTime
  id: Int
  identifier: String!
  updatedAt: DateTime
}

input CateogryCreateManyMenuInputEnvelope {
  data: [CateogryCreateManyMenuInput!]!
  skipDuplicates: Boolean
}

input CateogryCreateNestedManyWithoutMenuInput {
  connect: [CateogryWhereUniqueInput!]
  connectOrCreate: [CateogryCreateOrConnectWithoutMenuInput!]
  create: [CateogryCreateWithoutMenuInput!]
  createMany: CateogryCreateManyMenuInputEnvelope
}

input CateogryCreateNestedOneWithoutContentInput {
  connect: CateogryWhereUniqueInput
  connectOrCreate: CateogryCreateOrConnectWithoutContentInput
  create: CateogryCreateWithoutContentInput
}

input CateogryCreateNestedOneWithoutItemsInput {
  connect: CateogryWhereUniqueInput
  connectOrCreate: CateogryCreateOrConnectWithoutItemsInput
  create: CateogryCreateWithoutItemsInput
}

input CateogryCreateOrConnectWithoutContentInput {
  create: CateogryCreateWithoutContentInput!
  where: CateogryWhereUniqueInput!
}

input CateogryCreateOrConnectWithoutItemsInput {
  create: CateogryCreateWithoutItemsInput!
  where: CateogryWhereUniqueInput!
}

input CateogryCreateOrConnectWithoutMenuInput {
  create: CateogryCreateWithoutMenuInput!
  where: CateogryWhereUniqueInput!
}

input CateogryCreateWithoutContentInput {
  createdAt: DateTime
  identifier: String!
  items: ItemCreateNestedManyWithoutCategoryInput
  menu: MenuCreateNestedOneWithoutCategoriesInput!
  updatedAt: DateTime
}

input CateogryCreateWithoutItemsInput {
  content: CateogryI18LCreateNestedManyWithoutCategoryInput
  createdAt: DateTime
  identifier: String!
  menu: MenuCreateNestedOneWithoutCategoriesInput!
  updatedAt: DateTime
}

input CateogryCreateWithoutMenuInput {
  content: CateogryI18LCreateNestedManyWithoutCategoryInput
  createdAt: DateTime
  identifier: String!
  items: ItemCreateNestedManyWithoutCategoryInput
  updatedAt: DateTime
}

type CateogryGroupBy {
  _avg: CateogryAvgAggregate
  _count: CateogryCountAggregate
  _max: CateogryMaxAggregate
  _min: CateogryMinAggregate
  _sum: CateogrySumAggregate
  createdAt: DateTime!
  id: Int!
  identifier: String!
  menuId: Int!
  updatedAt: DateTime!
}

type CateogryI18L {
  category: Cateogry!
  categoryId: Int!
  description: String!
  id: Int!
  locale: Locale!
  name: String!
}

type CateogryI18LAvgAggregate {
  categoryId: Float
  id: Float
}

input CateogryI18LAvgOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
}

type CateogryI18LCountAggregate {
  _all: Int!
  categoryId: Int!
  description: Int!
  id: Int!
  locale: Int!
  name: Int!
}

input CateogryI18LCountOrderByAggregateInput {
  categoryId: SortOrder
  description: SortOrder
  id: SortOrder
  locale: SortOrder
  name: SortOrder
}

input CateogryI18LCreateInput {
  category: CateogryCreateNestedOneWithoutContentInput!
  description: String!
  locale: Locale!
  name: String!
}

input CateogryI18LCreateManyCategoryInput {
  description: String!
  id: Int
  locale: Locale!
  name: String!
}

input CateogryI18LCreateManyCategoryInputEnvelope {
  data: [CateogryI18LCreateManyCategoryInput!]!
  skipDuplicates: Boolean
}

input CateogryI18LCreateManyInput {
  categoryId: Int!
  description: String!
  id: Int
  locale: Locale!
  name: String!
}

input CateogryI18LCreateNestedManyWithoutCategoryInput {
  connect: [CateogryI18LWhereUniqueInput!]
  connectOrCreate: [CateogryI18LCreateOrConnectWithoutCategoryInput!]
  create: [CateogryI18LCreateWithoutCategoryInput!]
  createMany: CateogryI18LCreateManyCategoryInputEnvelope
}

input CateogryI18LCreateOrConnectWithoutCategoryInput {
  create: CateogryI18LCreateWithoutCategoryInput!
  where: CateogryI18LWhereUniqueInput!
}

input CateogryI18LCreateWithoutCategoryInput {
  description: String!
  locale: Locale!
  name: String!
}

type CateogryI18LGroupBy {
  _avg: CateogryI18LAvgAggregate
  _count: CateogryI18LCountAggregate
  _max: CateogryI18LMaxAggregate
  _min: CateogryI18LMinAggregate
  _sum: CateogryI18LSumAggregate
  categoryId: Int!
  description: String!
  id: Int!
  locale: Locale!
  name: String!
}

input CateogryI18LListRelationFilter {
  every: CateogryI18LWhereInput
  none: CateogryI18LWhereInput
  some: CateogryI18LWhereInput
}

type CateogryI18LMaxAggregate {
  categoryId: Int
  description: String
  id: Int
  locale: Locale
  name: String
}

input CateogryI18LMaxOrderByAggregateInput {
  categoryId: SortOrder
  description: SortOrder
  id: SortOrder
  locale: SortOrder
  name: SortOrder
}

type CateogryI18LMinAggregate {
  categoryId: Int
  description: String
  id: Int
  locale: Locale
  name: String
}

input CateogryI18LMinOrderByAggregateInput {
  categoryId: SortOrder
  description: SortOrder
  id: SortOrder
  locale: SortOrder
  name: SortOrder
}

input CateogryI18LOrderByRelationAggregateInput {
  _count: SortOrder
}

input CateogryI18LOrderByWithAggregationInput {
  _avg: CateogryI18LAvgOrderByAggregateInput
  _count: CateogryI18LCountOrderByAggregateInput
  _max: CateogryI18LMaxOrderByAggregateInput
  _min: CateogryI18LMinOrderByAggregateInput
  _sum: CateogryI18LSumOrderByAggregateInput
  categoryId: SortOrder
  description: SortOrder
  id: SortOrder
  locale: SortOrder
  name: SortOrder
}

input CateogryI18LOrderByWithRelationInput {
  category: CateogryOrderByWithRelationInput
  categoryId: SortOrder
  description: SortOrder
  id: SortOrder
  locale: SortOrder
  name: SortOrder
}

enum CateogryI18LScalarFieldEnum {
  categoryId
  description
  id
  locale
  name
}

input CateogryI18LScalarWhereInput {
  AND: [CateogryI18LScalarWhereInput!]
  NOT: [CateogryI18LScalarWhereInput!]
  OR: [CateogryI18LScalarWhereInput!]
  categoryId: IntFilter
  description: StringFilter
  id: IntFilter
  locale: EnumLocaleFilter
  name: StringFilter
}

input CateogryI18LScalarWhereWithAggregatesInput {
  AND: [CateogryI18LScalarWhereWithAggregatesInput!]
  NOT: [CateogryI18LScalarWhereWithAggregatesInput!]
  OR: [CateogryI18LScalarWhereWithAggregatesInput!]
  categoryId: IntWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  locale: EnumLocaleWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type CateogryI18LSumAggregate {
  categoryId: Int
  id: Int
}

input CateogryI18LSumOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
}

input CateogryI18LUpdateInput {
  category: CateogryUpdateOneRequiredWithoutContentInput
  description: StringFieldUpdateOperationsInput
  locale: EnumLocaleFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CateogryI18LUpdateManyMutationInput {
  description: StringFieldUpdateOperationsInput
  locale: EnumLocaleFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CateogryI18LUpdateManyWithWhereWithoutCategoryInput {
  data: CateogryI18LUpdateManyMutationInput!
  where: CateogryI18LScalarWhereInput!
}

input CateogryI18LUpdateManyWithoutCategoryInput {
  connect: [CateogryI18LWhereUniqueInput!]
  connectOrCreate: [CateogryI18LCreateOrConnectWithoutCategoryInput!]
  create: [CateogryI18LCreateWithoutCategoryInput!]
  createMany: CateogryI18LCreateManyCategoryInputEnvelope
  delete: [CateogryI18LWhereUniqueInput!]
  deleteMany: [CateogryI18LScalarWhereInput!]
  disconnect: [CateogryI18LWhereUniqueInput!]
  set: [CateogryI18LWhereUniqueInput!]
  update: [CateogryI18LUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [CateogryI18LUpdateManyWithWhereWithoutCategoryInput!]
  upsert: [CateogryI18LUpsertWithWhereUniqueWithoutCategoryInput!]
}

input CateogryI18LUpdateWithWhereUniqueWithoutCategoryInput {
  data: CateogryI18LUpdateWithoutCategoryInput!
  where: CateogryI18LWhereUniqueInput!
}

input CateogryI18LUpdateWithoutCategoryInput {
  description: StringFieldUpdateOperationsInput
  locale: EnumLocaleFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CateogryI18LUpsertWithWhereUniqueWithoutCategoryInput {
  create: CateogryI18LCreateWithoutCategoryInput!
  update: CateogryI18LUpdateWithoutCategoryInput!
  where: CateogryI18LWhereUniqueInput!
}

input CateogryI18LWhereInput {
  AND: [CateogryI18LWhereInput!]
  NOT: [CateogryI18LWhereInput!]
  OR: [CateogryI18LWhereInput!]
  category: CateogryRelationFilter
  categoryId: IntFilter
  description: StringFilter
  id: IntFilter
  locale: EnumLocaleFilter
  name: StringFilter
}

input CateogryI18LWhereUniqueInput {
  id: Int
}

input CateogryListRelationFilter {
  every: CateogryWhereInput
  none: CateogryWhereInput
  some: CateogryWhereInput
}

type CateogryMaxAggregate {
  createdAt: DateTime
  id: Int
  identifier: String
  menuId: Int
  updatedAt: DateTime
}

input CateogryMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  menuId: SortOrder
  updatedAt: SortOrder
}

type CateogryMinAggregate {
  createdAt: DateTime
  id: Int
  identifier: String
  menuId: Int
  updatedAt: DateTime
}

input CateogryMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  menuId: SortOrder
  updatedAt: SortOrder
}

input CateogryOrderByRelationAggregateInput {
  _count: SortOrder
}

input CateogryOrderByWithAggregationInput {
  _avg: CateogryAvgOrderByAggregateInput
  _count: CateogryCountOrderByAggregateInput
  _max: CateogryMaxOrderByAggregateInput
  _min: CateogryMinOrderByAggregateInput
  _sum: CateogrySumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  menuId: SortOrder
  updatedAt: SortOrder
}

input CateogryOrderByWithRelationInput {
  content: CateogryI18LOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  items: ItemOrderByRelationAggregateInput
  menu: MenuOrderByWithRelationInput
  menuId: SortOrder
  updatedAt: SortOrder
}

input CateogryRelationFilter {
  is: CateogryWhereInput
  isNot: CateogryWhereInput
}

enum CateogryScalarFieldEnum {
  createdAt
  id
  identifier
  menuId
  updatedAt
}

input CateogryScalarWhereInput {
  AND: [CateogryScalarWhereInput!]
  NOT: [CateogryScalarWhereInput!]
  OR: [CateogryScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  identifier: StringFilter
  menuId: IntFilter
  updatedAt: DateTimeFilter
}

input CateogryScalarWhereWithAggregatesInput {
  AND: [CateogryScalarWhereWithAggregatesInput!]
  NOT: [CateogryScalarWhereWithAggregatesInput!]
  OR: [CateogryScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  identifier: StringWithAggregatesFilter
  menuId: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type CateogrySumAggregate {
  id: Int
  menuId: Int
}

input CateogrySumOrderByAggregateInput {
  id: SortOrder
  menuId: SortOrder
}

input CateogryUpdateInput {
  content: CateogryI18LUpdateManyWithoutCategoryInput
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  items: ItemUpdateManyWithoutCategoryInput
  menu: MenuUpdateOneRequiredWithoutCategoriesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CateogryUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CateogryUpdateManyWithWhereWithoutMenuInput {
  data: CateogryUpdateManyMutationInput!
  where: CateogryScalarWhereInput!
}

input CateogryUpdateManyWithoutMenuInput {
  connect: [CateogryWhereUniqueInput!]
  connectOrCreate: [CateogryCreateOrConnectWithoutMenuInput!]
  create: [CateogryCreateWithoutMenuInput!]
  createMany: CateogryCreateManyMenuInputEnvelope
  delete: [CateogryWhereUniqueInput!]
  deleteMany: [CateogryScalarWhereInput!]
  disconnect: [CateogryWhereUniqueInput!]
  set: [CateogryWhereUniqueInput!]
  update: [CateogryUpdateWithWhereUniqueWithoutMenuInput!]
  updateMany: [CateogryUpdateManyWithWhereWithoutMenuInput!]
  upsert: [CateogryUpsertWithWhereUniqueWithoutMenuInput!]
}

input CateogryUpdateOneRequiredWithoutContentInput {
  connect: CateogryWhereUniqueInput
  connectOrCreate: CateogryCreateOrConnectWithoutContentInput
  create: CateogryCreateWithoutContentInput
  update: CateogryUpdateWithoutContentInput
  upsert: CateogryUpsertWithoutContentInput
}

input CateogryUpdateOneRequiredWithoutItemsInput {
  connect: CateogryWhereUniqueInput
  connectOrCreate: CateogryCreateOrConnectWithoutItemsInput
  create: CateogryCreateWithoutItemsInput
  update: CateogryUpdateWithoutItemsInput
  upsert: CateogryUpsertWithoutItemsInput
}

input CateogryUpdateWithWhereUniqueWithoutMenuInput {
  data: CateogryUpdateWithoutMenuInput!
  where: CateogryWhereUniqueInput!
}

input CateogryUpdateWithoutContentInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  items: ItemUpdateManyWithoutCategoryInput
  menu: MenuUpdateOneRequiredWithoutCategoriesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CateogryUpdateWithoutItemsInput {
  content: CateogryI18LUpdateManyWithoutCategoryInput
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  menu: MenuUpdateOneRequiredWithoutCategoriesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CateogryUpdateWithoutMenuInput {
  content: CateogryI18LUpdateManyWithoutCategoryInput
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  items: ItemUpdateManyWithoutCategoryInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CateogryUpsertWithWhereUniqueWithoutMenuInput {
  create: CateogryCreateWithoutMenuInput!
  update: CateogryUpdateWithoutMenuInput!
  where: CateogryWhereUniqueInput!
}

input CateogryUpsertWithoutContentInput {
  create: CateogryCreateWithoutContentInput!
  update: CateogryUpdateWithoutContentInput!
}

input CateogryUpsertWithoutItemsInput {
  create: CateogryCreateWithoutItemsInput!
  update: CateogryUpdateWithoutItemsInput!
}

input CateogryWhereInput {
  AND: [CateogryWhereInput!]
  NOT: [CateogryWhereInput!]
  OR: [CateogryWhereInput!]
  content: CateogryI18LListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  identifier: StringFilter
  items: ItemListRelationFilter
  menu: MenuRelationFilter
  menuId: IntFilter
  updatedAt: DateTimeFilter
}

input CateogryWhereUniqueInput {
  id: Int
  identifier: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumLocaleFieldUpdateOperationsInput {
  set: Locale
}

input EnumLocaleFilter {
  equals: Locale
  in: [Locale!]
  not: NestedEnumLocaleFilter
  notIn: [Locale!]
}

input EnumLocaleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumLocaleFilter
  _min: NestedEnumLocaleFilter
  equals: Locale
  in: [Locale!]
  not: NestedEnumLocaleWithAggregatesFilter
  notIn: [Locale!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Item {
  _count: ItemCount
  category: Cateogry!
  categoryId: Int!
  content(cursor: ItemI18LWhereUniqueInput, distinct: [ItemI18LScalarFieldEnum!], orderBy: [ItemI18LOrderByWithRelationInput!], skip: Int, take: Int, where: ItemI18LWhereInput): [ItemI18L!]!
  createdAt: DateTime!
  id: Int!
  identifier: String!
  image: String!
  items(cursor: OrderWhereUniqueInput, distinct: [OrderScalarFieldEnum!], orderBy: [OrderOrderByWithRelationInput!], skip: Int, take: Int, where: OrderWhereInput): [Order!]!
  price: Int!
  updatedAt: DateTime!
}

type ItemAvgAggregate {
  categoryId: Float
  id: Float
  price: Float
}

input ItemAvgOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
  price: SortOrder
}

type ItemCount {
  content: Int!
  items: Int!
}

type ItemCountAggregate {
  _all: Int!
  categoryId: Int!
  createdAt: Int!
  id: Int!
  identifier: Int!
  image: Int!
  price: Int!
  updatedAt: Int!
}

input ItemCountOrderByAggregateInput {
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  image: SortOrder
  price: SortOrder
  updatedAt: SortOrder
}

input ItemCreateInput {
  category: CateogryCreateNestedOneWithoutItemsInput!
  content: ItemI18LCreateNestedManyWithoutItemInput
  createdAt: DateTime
  identifier: String!
  image: String!
  items: OrderCreateNestedManyWithoutItemsInput
  price: Int!
  updatedAt: DateTime
}

input ItemCreateManyCategoryInput {
  createdAt: DateTime
  id: Int
  identifier: String!
  image: String!
  price: Int!
  updatedAt: DateTime
}

input ItemCreateManyCategoryInputEnvelope {
  data: [ItemCreateManyCategoryInput!]!
  skipDuplicates: Boolean
}

input ItemCreateManyInput {
  categoryId: Int!
  createdAt: DateTime
  id: Int
  identifier: String!
  image: String!
  price: Int!
  updatedAt: DateTime
}

input ItemCreateNestedManyWithoutCategoryInput {
  connect: [ItemWhereUniqueInput!]
  connectOrCreate: [ItemCreateOrConnectWithoutCategoryInput!]
  create: [ItemCreateWithoutCategoryInput!]
  createMany: ItemCreateManyCategoryInputEnvelope
}

input ItemCreateNestedManyWithoutItemsInput {
  connect: [ItemWhereUniqueInput!]
  connectOrCreate: [ItemCreateOrConnectWithoutItemsInput!]
  create: [ItemCreateWithoutItemsInput!]
}

input ItemCreateNestedOneWithoutContentInput {
  connect: ItemWhereUniqueInput
  connectOrCreate: ItemCreateOrConnectWithoutContentInput
  create: ItemCreateWithoutContentInput
}

input ItemCreateOrConnectWithoutCategoryInput {
  create: ItemCreateWithoutCategoryInput!
  where: ItemWhereUniqueInput!
}

input ItemCreateOrConnectWithoutContentInput {
  create: ItemCreateWithoutContentInput!
  where: ItemWhereUniqueInput!
}

input ItemCreateOrConnectWithoutItemsInput {
  create: ItemCreateWithoutItemsInput!
  where: ItemWhereUniqueInput!
}

input ItemCreateWithoutCategoryInput {
  content: ItemI18LCreateNestedManyWithoutItemInput
  createdAt: DateTime
  identifier: String!
  image: String!
  items: OrderCreateNestedManyWithoutItemsInput
  price: Int!
  updatedAt: DateTime
}

input ItemCreateWithoutContentInput {
  category: CateogryCreateNestedOneWithoutItemsInput!
  createdAt: DateTime
  identifier: String!
  image: String!
  items: OrderCreateNestedManyWithoutItemsInput
  price: Int!
  updatedAt: DateTime
}

input ItemCreateWithoutItemsInput {
  category: CateogryCreateNestedOneWithoutItemsInput!
  content: ItemI18LCreateNestedManyWithoutItemInput
  createdAt: DateTime
  identifier: String!
  image: String!
  price: Int!
  updatedAt: DateTime
}

type ItemGroupBy {
  _avg: ItemAvgAggregate
  _count: ItemCountAggregate
  _max: ItemMaxAggregate
  _min: ItemMinAggregate
  _sum: ItemSumAggregate
  categoryId: Int!
  createdAt: DateTime!
  id: Int!
  identifier: String!
  image: String!
  price: Int!
  updatedAt: DateTime!
}

type ItemI18L {
  description: String!
  id: Int!
  item: Item!
  itemId: Int!
  locale: Locale!
  name: String!
}

type ItemI18LAvgAggregate {
  id: Float
  itemId: Float
}

input ItemI18LAvgOrderByAggregateInput {
  id: SortOrder
  itemId: SortOrder
}

type ItemI18LCountAggregate {
  _all: Int!
  description: Int!
  id: Int!
  itemId: Int!
  locale: Int!
  name: Int!
}

input ItemI18LCountOrderByAggregateInput {
  description: SortOrder
  id: SortOrder
  itemId: SortOrder
  locale: SortOrder
  name: SortOrder
}

input ItemI18LCreateInput {
  description: String!
  item: ItemCreateNestedOneWithoutContentInput!
  locale: Locale!
  name: String!
}

input ItemI18LCreateManyInput {
  description: String!
  id: Int
  itemId: Int!
  locale: Locale!
  name: String!
}

input ItemI18LCreateManyItemInput {
  description: String!
  id: Int
  locale: Locale!
  name: String!
}

input ItemI18LCreateManyItemInputEnvelope {
  data: [ItemI18LCreateManyItemInput!]!
  skipDuplicates: Boolean
}

input ItemI18LCreateNestedManyWithoutItemInput {
  connect: [ItemI18LWhereUniqueInput!]
  connectOrCreate: [ItemI18LCreateOrConnectWithoutItemInput!]
  create: [ItemI18LCreateWithoutItemInput!]
  createMany: ItemI18LCreateManyItemInputEnvelope
}

input ItemI18LCreateOrConnectWithoutItemInput {
  create: ItemI18LCreateWithoutItemInput!
  where: ItemI18LWhereUniqueInput!
}

input ItemI18LCreateWithoutItemInput {
  description: String!
  locale: Locale!
  name: String!
}

type ItemI18LGroupBy {
  _avg: ItemI18LAvgAggregate
  _count: ItemI18LCountAggregate
  _max: ItemI18LMaxAggregate
  _min: ItemI18LMinAggregate
  _sum: ItemI18LSumAggregate
  description: String!
  id: Int!
  itemId: Int!
  locale: Locale!
  name: String!
}

input ItemI18LListRelationFilter {
  every: ItemI18LWhereInput
  none: ItemI18LWhereInput
  some: ItemI18LWhereInput
}

type ItemI18LMaxAggregate {
  description: String
  id: Int
  itemId: Int
  locale: Locale
  name: String
}

input ItemI18LMaxOrderByAggregateInput {
  description: SortOrder
  id: SortOrder
  itemId: SortOrder
  locale: SortOrder
  name: SortOrder
}

type ItemI18LMinAggregate {
  description: String
  id: Int
  itemId: Int
  locale: Locale
  name: String
}

input ItemI18LMinOrderByAggregateInput {
  description: SortOrder
  id: SortOrder
  itemId: SortOrder
  locale: SortOrder
  name: SortOrder
}

input ItemI18LOrderByRelationAggregateInput {
  _count: SortOrder
}

input ItemI18LOrderByWithAggregationInput {
  _avg: ItemI18LAvgOrderByAggregateInput
  _count: ItemI18LCountOrderByAggregateInput
  _max: ItemI18LMaxOrderByAggregateInput
  _min: ItemI18LMinOrderByAggregateInput
  _sum: ItemI18LSumOrderByAggregateInput
  description: SortOrder
  id: SortOrder
  itemId: SortOrder
  locale: SortOrder
  name: SortOrder
}

input ItemI18LOrderByWithRelationInput {
  description: SortOrder
  id: SortOrder
  item: ItemOrderByWithRelationInput
  itemId: SortOrder
  locale: SortOrder
  name: SortOrder
}

enum ItemI18LScalarFieldEnum {
  description
  id
  itemId
  locale
  name
}

input ItemI18LScalarWhereInput {
  AND: [ItemI18LScalarWhereInput!]
  NOT: [ItemI18LScalarWhereInput!]
  OR: [ItemI18LScalarWhereInput!]
  description: StringFilter
  id: IntFilter
  itemId: IntFilter
  locale: EnumLocaleFilter
  name: StringFilter
}

input ItemI18LScalarWhereWithAggregatesInput {
  AND: [ItemI18LScalarWhereWithAggregatesInput!]
  NOT: [ItemI18LScalarWhereWithAggregatesInput!]
  OR: [ItemI18LScalarWhereWithAggregatesInput!]
  description: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  itemId: IntWithAggregatesFilter
  locale: EnumLocaleWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type ItemI18LSumAggregate {
  id: Int
  itemId: Int
}

input ItemI18LSumOrderByAggregateInput {
  id: SortOrder
  itemId: SortOrder
}

input ItemI18LUpdateInput {
  description: StringFieldUpdateOperationsInput
  item: ItemUpdateOneRequiredWithoutContentInput
  locale: EnumLocaleFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ItemI18LUpdateManyMutationInput {
  description: StringFieldUpdateOperationsInput
  locale: EnumLocaleFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ItemI18LUpdateManyWithWhereWithoutItemInput {
  data: ItemI18LUpdateManyMutationInput!
  where: ItemI18LScalarWhereInput!
}

input ItemI18LUpdateManyWithoutItemInput {
  connect: [ItemI18LWhereUniqueInput!]
  connectOrCreate: [ItemI18LCreateOrConnectWithoutItemInput!]
  create: [ItemI18LCreateWithoutItemInput!]
  createMany: ItemI18LCreateManyItemInputEnvelope
  delete: [ItemI18LWhereUniqueInput!]
  deleteMany: [ItemI18LScalarWhereInput!]
  disconnect: [ItemI18LWhereUniqueInput!]
  set: [ItemI18LWhereUniqueInput!]
  update: [ItemI18LUpdateWithWhereUniqueWithoutItemInput!]
  updateMany: [ItemI18LUpdateManyWithWhereWithoutItemInput!]
  upsert: [ItemI18LUpsertWithWhereUniqueWithoutItemInput!]
}

input ItemI18LUpdateWithWhereUniqueWithoutItemInput {
  data: ItemI18LUpdateWithoutItemInput!
  where: ItemI18LWhereUniqueInput!
}

input ItemI18LUpdateWithoutItemInput {
  description: StringFieldUpdateOperationsInput
  locale: EnumLocaleFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ItemI18LUpsertWithWhereUniqueWithoutItemInput {
  create: ItemI18LCreateWithoutItemInput!
  update: ItemI18LUpdateWithoutItemInput!
  where: ItemI18LWhereUniqueInput!
}

input ItemI18LWhereInput {
  AND: [ItemI18LWhereInput!]
  NOT: [ItemI18LWhereInput!]
  OR: [ItemI18LWhereInput!]
  description: StringFilter
  id: IntFilter
  item: ItemRelationFilter
  itemId: IntFilter
  locale: EnumLocaleFilter
  name: StringFilter
}

input ItemI18LWhereUniqueInput {
  id: Int
}

input ItemListRelationFilter {
  every: ItemWhereInput
  none: ItemWhereInput
  some: ItemWhereInput
}

type ItemMaxAggregate {
  categoryId: Int
  createdAt: DateTime
  id: Int
  identifier: String
  image: String
  price: Int
  updatedAt: DateTime
}

input ItemMaxOrderByAggregateInput {
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  image: SortOrder
  price: SortOrder
  updatedAt: SortOrder
}

type ItemMinAggregate {
  categoryId: Int
  createdAt: DateTime
  id: Int
  identifier: String
  image: String
  price: Int
  updatedAt: DateTime
}

input ItemMinOrderByAggregateInput {
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  image: SortOrder
  price: SortOrder
  updatedAt: SortOrder
}

input ItemOrderByRelationAggregateInput {
  _count: SortOrder
}

input ItemOrderByWithAggregationInput {
  _avg: ItemAvgOrderByAggregateInput
  _count: ItemCountOrderByAggregateInput
  _max: ItemMaxOrderByAggregateInput
  _min: ItemMinOrderByAggregateInput
  _sum: ItemSumOrderByAggregateInput
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  image: SortOrder
  price: SortOrder
  updatedAt: SortOrder
}

input ItemOrderByWithRelationInput {
  category: CateogryOrderByWithRelationInput
  categoryId: SortOrder
  content: ItemI18LOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  image: SortOrder
  items: OrderOrderByRelationAggregateInput
  price: SortOrder
  updatedAt: SortOrder
}

input ItemRelationFilter {
  is: ItemWhereInput
  isNot: ItemWhereInput
}

enum ItemScalarFieldEnum {
  categoryId
  createdAt
  id
  identifier
  image
  price
  updatedAt
}

input ItemScalarWhereInput {
  AND: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  categoryId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  identifier: StringFilter
  image: StringFilter
  price: IntFilter
  updatedAt: DateTimeFilter
}

input ItemScalarWhereWithAggregatesInput {
  AND: [ItemScalarWhereWithAggregatesInput!]
  NOT: [ItemScalarWhereWithAggregatesInput!]
  OR: [ItemScalarWhereWithAggregatesInput!]
  categoryId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  identifier: StringWithAggregatesFilter
  image: StringWithAggregatesFilter
  price: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ItemSumAggregate {
  categoryId: Int
  id: Int
  price: Int
}

input ItemSumOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
  price: SortOrder
}

input ItemUpdateInput {
  category: CateogryUpdateOneRequiredWithoutItemsInput
  content: ItemI18LUpdateManyWithoutItemInput
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  items: OrderUpdateManyWithoutItemsInput
  price: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ItemUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  price: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ItemUpdateManyWithWhereWithoutCategoryInput {
  data: ItemUpdateManyMutationInput!
  where: ItemScalarWhereInput!
}

input ItemUpdateManyWithWhereWithoutItemsInput {
  data: ItemUpdateManyMutationInput!
  where: ItemScalarWhereInput!
}

input ItemUpdateManyWithoutCategoryInput {
  connect: [ItemWhereUniqueInput!]
  connectOrCreate: [ItemCreateOrConnectWithoutCategoryInput!]
  create: [ItemCreateWithoutCategoryInput!]
  createMany: ItemCreateManyCategoryInputEnvelope
  delete: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  disconnect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [ItemUpdateManyWithWhereWithoutCategoryInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutCategoryInput!]
}

input ItemUpdateManyWithoutItemsInput {
  connect: [ItemWhereUniqueInput!]
  connectOrCreate: [ItemCreateOrConnectWithoutItemsInput!]
  create: [ItemCreateWithoutItemsInput!]
  delete: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  disconnect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutItemsInput!]
  updateMany: [ItemUpdateManyWithWhereWithoutItemsInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutItemsInput!]
}

input ItemUpdateOneRequiredWithoutContentInput {
  connect: ItemWhereUniqueInput
  connectOrCreate: ItemCreateOrConnectWithoutContentInput
  create: ItemCreateWithoutContentInput
  update: ItemUpdateWithoutContentInput
  upsert: ItemUpsertWithoutContentInput
}

input ItemUpdateWithWhereUniqueWithoutCategoryInput {
  data: ItemUpdateWithoutCategoryInput!
  where: ItemWhereUniqueInput!
}

input ItemUpdateWithWhereUniqueWithoutItemsInput {
  data: ItemUpdateWithoutItemsInput!
  where: ItemWhereUniqueInput!
}

input ItemUpdateWithoutCategoryInput {
  content: ItemI18LUpdateManyWithoutItemInput
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  items: OrderUpdateManyWithoutItemsInput
  price: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ItemUpdateWithoutContentInput {
  category: CateogryUpdateOneRequiredWithoutItemsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  items: OrderUpdateManyWithoutItemsInput
  price: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ItemUpdateWithoutItemsInput {
  category: CateogryUpdateOneRequiredWithoutItemsInput
  content: ItemI18LUpdateManyWithoutItemInput
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  price: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ItemUpsertWithWhereUniqueWithoutCategoryInput {
  create: ItemCreateWithoutCategoryInput!
  update: ItemUpdateWithoutCategoryInput!
  where: ItemWhereUniqueInput!
}

input ItemUpsertWithWhereUniqueWithoutItemsInput {
  create: ItemCreateWithoutItemsInput!
  update: ItemUpdateWithoutItemsInput!
  where: ItemWhereUniqueInput!
}

input ItemUpsertWithoutContentInput {
  create: ItemCreateWithoutContentInput!
  update: ItemUpdateWithoutContentInput!
}

input ItemWhereInput {
  AND: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  category: CateogryRelationFilter
  categoryId: IntFilter
  content: ItemI18LListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  identifier: StringFilter
  image: StringFilter
  items: OrderListRelationFilter
  price: IntFilter
  updatedAt: DateTimeFilter
}

input ItemWhereUniqueInput {
  id: Int
}

enum Locale {
  en
  he
}

type Menu {
  _count: MenuCount
  categories(cursor: CateogryWhereUniqueInput, distinct: [CateogryScalarFieldEnum!], orderBy: [CateogryOrderByWithRelationInput!], skip: Int, take: Int, where: CateogryWhereInput): [Cateogry!]!
  createdAt: DateTime!
  id: Int!
  identifier: String!
  restaurant: Restaurant!
  restaurantId: Int!
  updatedAt: DateTime!
}

type MenuAvgAggregate {
  id: Float
  restaurantId: Float
}

input MenuAvgOrderByAggregateInput {
  id: SortOrder
  restaurantId: SortOrder
}

type MenuCount {
  categories: Int!
}

type MenuCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  identifier: Int!
  restaurantId: Int!
  updatedAt: Int!
}

input MenuCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  restaurantId: SortOrder
  updatedAt: SortOrder
}

input MenuCreateInput {
  categories: CateogryCreateNestedManyWithoutMenuInput
  createdAt: DateTime
  identifier: String!
  restaurant: RestaurantCreateNestedOneWithoutMenuInput!
  updatedAt: DateTime
}

input MenuCreateManyInput {
  createdAt: DateTime
  id: Int
  identifier: String!
  restaurantId: Int!
  updatedAt: DateTime
}

input MenuCreateNestedOneWithoutCategoriesInput {
  connect: MenuWhereUniqueInput
  connectOrCreate: MenuCreateOrConnectWithoutCategoriesInput
  create: MenuCreateWithoutCategoriesInput
}

input MenuCreateNestedOneWithoutRestaurantInput {
  connect: MenuWhereUniqueInput
  connectOrCreate: MenuCreateOrConnectWithoutRestaurantInput
  create: MenuCreateWithoutRestaurantInput
}

input MenuCreateOrConnectWithoutCategoriesInput {
  create: MenuCreateWithoutCategoriesInput!
  where: MenuWhereUniqueInput!
}

input MenuCreateOrConnectWithoutRestaurantInput {
  create: MenuCreateWithoutRestaurantInput!
  where: MenuWhereUniqueInput!
}

input MenuCreateWithoutCategoriesInput {
  createdAt: DateTime
  identifier: String!
  restaurant: RestaurantCreateNestedOneWithoutMenuInput!
  updatedAt: DateTime
}

input MenuCreateWithoutRestaurantInput {
  categories: CateogryCreateNestedManyWithoutMenuInput
  createdAt: DateTime
  identifier: String!
  updatedAt: DateTime
}

type MenuGroupBy {
  _avg: MenuAvgAggregate
  _count: MenuCountAggregate
  _max: MenuMaxAggregate
  _min: MenuMinAggregate
  _sum: MenuSumAggregate
  createdAt: DateTime!
  id: Int!
  identifier: String!
  restaurantId: Int!
  updatedAt: DateTime!
}

type MenuMaxAggregate {
  createdAt: DateTime
  id: Int
  identifier: String
  restaurantId: Int
  updatedAt: DateTime
}

input MenuMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  restaurantId: SortOrder
  updatedAt: SortOrder
}

type MenuMinAggregate {
  createdAt: DateTime
  id: Int
  identifier: String
  restaurantId: Int
  updatedAt: DateTime
}

input MenuMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  restaurantId: SortOrder
  updatedAt: SortOrder
}

input MenuOrderByWithAggregationInput {
  _avg: MenuAvgOrderByAggregateInput
  _count: MenuCountOrderByAggregateInput
  _max: MenuMaxOrderByAggregateInput
  _min: MenuMinOrderByAggregateInput
  _sum: MenuSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  restaurantId: SortOrder
  updatedAt: SortOrder
}

input MenuOrderByWithRelationInput {
  categories: CateogryOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  restaurant: RestaurantOrderByWithRelationInput
  restaurantId: SortOrder
  updatedAt: SortOrder
}

input MenuRelationFilter {
  is: MenuWhereInput
  isNot: MenuWhereInput
}

enum MenuScalarFieldEnum {
  createdAt
  id
  identifier
  restaurantId
  updatedAt
}

input MenuScalarWhereWithAggregatesInput {
  AND: [MenuScalarWhereWithAggregatesInput!]
  NOT: [MenuScalarWhereWithAggregatesInput!]
  OR: [MenuScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  identifier: StringWithAggregatesFilter
  restaurantId: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type MenuSumAggregate {
  id: Int
  restaurantId: Int
}

input MenuSumOrderByAggregateInput {
  id: SortOrder
  restaurantId: SortOrder
}

input MenuUpdateInput {
  categories: CateogryUpdateManyWithoutMenuInput
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  restaurant: RestaurantUpdateOneRequiredWithoutMenuInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input MenuUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input MenuUpdateOneRequiredWithoutCategoriesInput {
  connect: MenuWhereUniqueInput
  connectOrCreate: MenuCreateOrConnectWithoutCategoriesInput
  create: MenuCreateWithoutCategoriesInput
  update: MenuUpdateWithoutCategoriesInput
  upsert: MenuUpsertWithoutCategoriesInput
}

input MenuUpdateOneWithoutRestaurantInput {
  connect: MenuWhereUniqueInput
  connectOrCreate: MenuCreateOrConnectWithoutRestaurantInput
  create: MenuCreateWithoutRestaurantInput
  delete: Boolean
  disconnect: Boolean
  update: MenuUpdateWithoutRestaurantInput
  upsert: MenuUpsertWithoutRestaurantInput
}

input MenuUpdateWithoutCategoriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  restaurant: RestaurantUpdateOneRequiredWithoutMenuInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input MenuUpdateWithoutRestaurantInput {
  categories: CateogryUpdateManyWithoutMenuInput
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input MenuUpsertWithoutCategoriesInput {
  create: MenuCreateWithoutCategoriesInput!
  update: MenuUpdateWithoutCategoriesInput!
}

input MenuUpsertWithoutRestaurantInput {
  create: MenuCreateWithoutRestaurantInput!
  update: MenuUpdateWithoutRestaurantInput!
}

input MenuWhereInput {
  AND: [MenuWhereInput!]
  NOT: [MenuWhereInput!]
  OR: [MenuWhereInput!]
  categories: CateogryListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  identifier: StringFilter
  restaurant: RestaurantRelationFilter
  restaurantId: IntFilter
  updatedAt: DateTimeFilter
}

input MenuWhereUniqueInput {
  id: Int
  identifier: String
  restaurantId: Int
}

type Mutation {
  createCateogry(data: CateogryCreateInput!): Cateogry!
  createCateogryI18L(data: CateogryI18LCreateInput!): CateogryI18L!
  createItem(data: ItemCreateInput!): Item!
  createItemI18L(data: ItemI18LCreateInput!): ItemI18L!
  createManyCateogry(data: [CateogryCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCateogryI18L(data: [CateogryI18LCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyItem(data: [ItemCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyItemI18L(data: [ItemI18LCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMenu(data: [MenuCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyOrder(data: [OrderCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyRestaurant(data: [RestaurantCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyRestaurantI18L(data: [RestaurantI18LCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createMenu(data: MenuCreateInput!): Menu!
  createOrder(data: OrderCreateInput!): Order!
  createRestaurant(data: RestaurantCreateInput!): Restaurant!
  createRestaurantI18L(data: RestaurantI18LCreateInput!): RestaurantI18L!
  createUser(data: UserCreateInput!): User!
  deleteCateogry(where: CateogryWhereUniqueInput!): Cateogry
  deleteCateogryI18L(where: CateogryI18LWhereUniqueInput!): CateogryI18L
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteItemI18L(where: ItemI18LWhereUniqueInput!): ItemI18L
  deleteManyCateogry(where: CateogryWhereInput): AffectedRowsOutput!
  deleteManyCateogryI18L(where: CateogryI18LWhereInput): AffectedRowsOutput!
  deleteManyItem(where: ItemWhereInput): AffectedRowsOutput!
  deleteManyItemI18L(where: ItemI18LWhereInput): AffectedRowsOutput!
  deleteManyMenu(where: MenuWhereInput): AffectedRowsOutput!
  deleteManyOrder(where: OrderWhereInput): AffectedRowsOutput!
  deleteManyRestaurant(where: RestaurantWhereInput): AffectedRowsOutput!
  deleteManyRestaurantI18L(where: RestaurantI18LWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteMenu(where: MenuWhereUniqueInput!): Menu
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteRestaurant(where: RestaurantWhereUniqueInput!): Restaurant
  deleteRestaurantI18L(where: RestaurantI18LWhereUniqueInput!): RestaurantI18L
  deleteUser(where: UserWhereUniqueInput!): User
  updateCateogry(data: CateogryUpdateInput!, where: CateogryWhereUniqueInput!): Cateogry
  updateCateogryI18L(data: CateogryI18LUpdateInput!, where: CateogryI18LWhereUniqueInput!): CateogryI18L
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateItemI18L(data: ItemI18LUpdateInput!, where: ItemI18LWhereUniqueInput!): ItemI18L
  updateManyCateogry(data: CateogryUpdateManyMutationInput!, where: CateogryWhereInput): AffectedRowsOutput!
  updateManyCateogryI18L(data: CateogryI18LUpdateManyMutationInput!, where: CateogryI18LWhereInput): AffectedRowsOutput!
  updateManyItem(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): AffectedRowsOutput!
  updateManyItemI18L(data: ItemI18LUpdateManyMutationInput!, where: ItemI18LWhereInput): AffectedRowsOutput!
  updateManyMenu(data: MenuUpdateManyMutationInput!, where: MenuWhereInput): AffectedRowsOutput!
  updateManyOrder(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): AffectedRowsOutput!
  updateManyRestaurant(data: RestaurantUpdateManyMutationInput!, where: RestaurantWhereInput): AffectedRowsOutput!
  updateManyRestaurantI18L(data: RestaurantI18LUpdateManyMutationInput!, where: RestaurantI18LWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateMenu(data: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateRestaurant(data: RestaurantUpdateInput!, where: RestaurantWhereUniqueInput!): Restaurant
  updateRestaurantI18L(data: RestaurantI18LUpdateInput!, where: RestaurantI18LWhereUniqueInput!): RestaurantI18L
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertCateogry(create: CateogryCreateInput!, update: CateogryUpdateInput!, where: CateogryWhereUniqueInput!): Cateogry!
  upsertCateogryI18L(create: CateogryI18LCreateInput!, update: CateogryI18LUpdateInput!, where: CateogryI18LWhereUniqueInput!): CateogryI18L!
  upsertItem(create: ItemCreateInput!, update: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item!
  upsertItemI18L(create: ItemI18LCreateInput!, update: ItemI18LUpdateInput!, where: ItemI18LWhereUniqueInput!): ItemI18L!
  upsertMenu(create: MenuCreateInput!, update: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu!
  upsertOrder(create: OrderCreateInput!, update: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order!
  upsertRestaurant(create: RestaurantCreateInput!, update: RestaurantUpdateInput!, where: RestaurantWhereUniqueInput!): Restaurant!
  upsertRestaurantI18L(create: RestaurantI18LCreateInput!, update: RestaurantI18LUpdateInput!, where: RestaurantI18LWhereUniqueInput!): RestaurantI18L!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumLocaleFilter {
  equals: Locale
  in: [Locale!]
  not: NestedEnumLocaleFilter
  notIn: [Locale!]
}

input NestedEnumLocaleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumLocaleFilter
  _min: NestedEnumLocaleFilter
  equals: Locale
  in: [Locale!]
  not: NestedEnumLocaleWithAggregatesFilter
  notIn: [Locale!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Order {
  _count: OrderCount
  createdAt: DateTime!
  id: Int!
  identifier: String!
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  restaurant: Restaurant!
  restaurantId: Int!
  table: String!
  updatedAt: DateTime!
}

type OrderAvgAggregate {
  id: Float
  restaurantId: Float
}

input OrderAvgOrderByAggregateInput {
  id: SortOrder
  restaurantId: SortOrder
}

type OrderCount {
  items: Int!
}

type OrderCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  identifier: Int!
  restaurantId: Int!
  table: Int!
  updatedAt: Int!
}

input OrderCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  restaurantId: SortOrder
  table: SortOrder
  updatedAt: SortOrder
}

input OrderCreateInput {
  createdAt: DateTime
  identifier: String!
  items: ItemCreateNestedManyWithoutItemsInput
  restaurant: RestaurantCreateNestedOneWithoutOrderInput!
  table: String!
  updatedAt: DateTime
}

input OrderCreateManyInput {
  createdAt: DateTime
  id: Int
  identifier: String!
  restaurantId: Int!
  table: String!
  updatedAt: DateTime
}

input OrderCreateManyRestaurantInput {
  createdAt: DateTime
  id: Int
  identifier: String!
  table: String!
  updatedAt: DateTime
}

input OrderCreateManyRestaurantInputEnvelope {
  data: [OrderCreateManyRestaurantInput!]!
  skipDuplicates: Boolean
}

input OrderCreateNestedManyWithoutItemsInput {
  connect: [OrderWhereUniqueInput!]
  connectOrCreate: [OrderCreateOrConnectWithoutItemsInput!]
  create: [OrderCreateWithoutItemsInput!]
}

input OrderCreateNestedManyWithoutRestaurantInput {
  connect: [OrderWhereUniqueInput!]
  connectOrCreate: [OrderCreateOrConnectWithoutRestaurantInput!]
  create: [OrderCreateWithoutRestaurantInput!]
  createMany: OrderCreateManyRestaurantInputEnvelope
}

input OrderCreateOrConnectWithoutItemsInput {
  create: OrderCreateWithoutItemsInput!
  where: OrderWhereUniqueInput!
}

input OrderCreateOrConnectWithoutRestaurantInput {
  create: OrderCreateWithoutRestaurantInput!
  where: OrderWhereUniqueInput!
}

input OrderCreateWithoutItemsInput {
  createdAt: DateTime
  identifier: String!
  restaurant: RestaurantCreateNestedOneWithoutOrderInput!
  table: String!
  updatedAt: DateTime
}

input OrderCreateWithoutRestaurantInput {
  createdAt: DateTime
  identifier: String!
  items: ItemCreateNestedManyWithoutItemsInput
  table: String!
  updatedAt: DateTime
}

type OrderGroupBy {
  _avg: OrderAvgAggregate
  _count: OrderCountAggregate
  _max: OrderMaxAggregate
  _min: OrderMinAggregate
  _sum: OrderSumAggregate
  createdAt: DateTime!
  id: Int!
  identifier: String!
  restaurantId: Int!
  table: String!
  updatedAt: DateTime!
}

input OrderListRelationFilter {
  every: OrderWhereInput
  none: OrderWhereInput
  some: OrderWhereInput
}

type OrderMaxAggregate {
  createdAt: DateTime
  id: Int
  identifier: String
  restaurantId: Int
  table: String
  updatedAt: DateTime
}

input OrderMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  restaurantId: SortOrder
  table: SortOrder
  updatedAt: SortOrder
}

type OrderMinAggregate {
  createdAt: DateTime
  id: Int
  identifier: String
  restaurantId: Int
  table: String
  updatedAt: DateTime
}

input OrderMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  restaurantId: SortOrder
  table: SortOrder
  updatedAt: SortOrder
}

input OrderOrderByRelationAggregateInput {
  _count: SortOrder
}

input OrderOrderByWithAggregationInput {
  _avg: OrderAvgOrderByAggregateInput
  _count: OrderCountOrderByAggregateInput
  _max: OrderMaxOrderByAggregateInput
  _min: OrderMinOrderByAggregateInput
  _sum: OrderSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  restaurantId: SortOrder
  table: SortOrder
  updatedAt: SortOrder
}

input OrderOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  items: ItemOrderByRelationAggregateInput
  restaurant: RestaurantOrderByWithRelationInput
  restaurantId: SortOrder
  table: SortOrder
  updatedAt: SortOrder
}

enum OrderScalarFieldEnum {
  createdAt
  id
  identifier
  restaurantId
  table
  updatedAt
}

input OrderScalarWhereInput {
  AND: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  identifier: StringFilter
  restaurantId: IntFilter
  table: StringFilter
  updatedAt: DateTimeFilter
}

input OrderScalarWhereWithAggregatesInput {
  AND: [OrderScalarWhereWithAggregatesInput!]
  NOT: [OrderScalarWhereWithAggregatesInput!]
  OR: [OrderScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  identifier: StringWithAggregatesFilter
  restaurantId: IntWithAggregatesFilter
  table: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type OrderSumAggregate {
  id: Int
  restaurantId: Int
}

input OrderSumOrderByAggregateInput {
  id: SortOrder
  restaurantId: SortOrder
}

input OrderUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  items: ItemUpdateManyWithoutItemsInput
  restaurant: RestaurantUpdateOneRequiredWithoutOrderInput
  table: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input OrderUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  table: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input OrderUpdateManyWithWhereWithoutItemsInput {
  data: OrderUpdateManyMutationInput!
  where: OrderScalarWhereInput!
}

input OrderUpdateManyWithWhereWithoutRestaurantInput {
  data: OrderUpdateManyMutationInput!
  where: OrderScalarWhereInput!
}

input OrderUpdateManyWithoutItemsInput {
  connect: [OrderWhereUniqueInput!]
  connectOrCreate: [OrderCreateOrConnectWithoutItemsInput!]
  create: [OrderCreateWithoutItemsInput!]
  delete: [OrderWhereUniqueInput!]
  deleteMany: [OrderScalarWhereInput!]
  disconnect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutItemsInput!]
  updateMany: [OrderUpdateManyWithWhereWithoutItemsInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutItemsInput!]
}

input OrderUpdateManyWithoutRestaurantInput {
  connect: [OrderWhereUniqueInput!]
  connectOrCreate: [OrderCreateOrConnectWithoutRestaurantInput!]
  create: [OrderCreateWithoutRestaurantInput!]
  createMany: OrderCreateManyRestaurantInputEnvelope
  delete: [OrderWhereUniqueInput!]
  deleteMany: [OrderScalarWhereInput!]
  disconnect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutRestaurantInput!]
  updateMany: [OrderUpdateManyWithWhereWithoutRestaurantInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutRestaurantInput!]
}

input OrderUpdateWithWhereUniqueWithoutItemsInput {
  data: OrderUpdateWithoutItemsInput!
  where: OrderWhereUniqueInput!
}

input OrderUpdateWithWhereUniqueWithoutRestaurantInput {
  data: OrderUpdateWithoutRestaurantInput!
  where: OrderWhereUniqueInput!
}

input OrderUpdateWithoutItemsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  restaurant: RestaurantUpdateOneRequiredWithoutOrderInput
  table: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input OrderUpdateWithoutRestaurantInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  items: ItemUpdateManyWithoutItemsInput
  table: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input OrderUpsertWithWhereUniqueWithoutItemsInput {
  create: OrderCreateWithoutItemsInput!
  update: OrderUpdateWithoutItemsInput!
  where: OrderWhereUniqueInput!
}

input OrderUpsertWithWhereUniqueWithoutRestaurantInput {
  create: OrderCreateWithoutRestaurantInput!
  update: OrderUpdateWithoutRestaurantInput!
  where: OrderWhereUniqueInput!
}

input OrderWhereInput {
  AND: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  identifier: StringFilter
  items: ItemListRelationFilter
  restaurant: RestaurantRelationFilter
  restaurantId: IntFilter
  table: StringFilter
  updatedAt: DateTimeFilter
}

input OrderWhereUniqueInput {
  id: Int
  identifier: String
}

type Query {
  aggregateCateogry(cursor: CateogryWhereUniqueInput, orderBy: [CateogryOrderByWithRelationInput!], skip: Int, take: Int, where: CateogryWhereInput): AggregateCateogry!
  aggregateCateogryI18L(cursor: CateogryI18LWhereUniqueInput, orderBy: [CateogryI18LOrderByWithRelationInput!], skip: Int, take: Int, where: CateogryI18LWhereInput): AggregateCateogryI18L!
  aggregateItem(cursor: ItemWhereUniqueInput, orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): AggregateItem!
  aggregateItemI18L(cursor: ItemI18LWhereUniqueInput, orderBy: [ItemI18LOrderByWithRelationInput!], skip: Int, take: Int, where: ItemI18LWhereInput): AggregateItemI18L!
  aggregateMenu(cursor: MenuWhereUniqueInput, orderBy: [MenuOrderByWithRelationInput!], skip: Int, take: Int, where: MenuWhereInput): AggregateMenu!
  aggregateOrder(cursor: OrderWhereUniqueInput, orderBy: [OrderOrderByWithRelationInput!], skip: Int, take: Int, where: OrderWhereInput): AggregateOrder!
  aggregateRestaurant(cursor: RestaurantWhereUniqueInput, orderBy: [RestaurantOrderByWithRelationInput!], skip: Int, take: Int, where: RestaurantWhereInput): AggregateRestaurant!
  aggregateRestaurantI18L(cursor: RestaurantI18LWhereUniqueInput, orderBy: [RestaurantI18LOrderByWithRelationInput!], skip: Int, take: Int, where: RestaurantI18LWhereInput): AggregateRestaurantI18L!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  cateogries(cursor: CateogryWhereUniqueInput, distinct: [CateogryScalarFieldEnum!], orderBy: [CateogryOrderByWithRelationInput!], skip: Int, take: Int, where: CateogryWhereInput): [Cateogry!]!
  cateogry(where: CateogryWhereUniqueInput!): Cateogry
  cateogryI18L(where: CateogryI18LWhereUniqueInput!): CateogryI18L
  cateogryI18LS(cursor: CateogryI18LWhereUniqueInput, distinct: [CateogryI18LScalarFieldEnum!], orderBy: [CateogryI18LOrderByWithRelationInput!], skip: Int, take: Int, where: CateogryI18LWhereInput): [CateogryI18L!]!
  findFirstCateogry(cursor: CateogryWhereUniqueInput, distinct: [CateogryScalarFieldEnum!], orderBy: [CateogryOrderByWithRelationInput!], skip: Int, take: Int, where: CateogryWhereInput): Cateogry
  findFirstCateogryI18L(cursor: CateogryI18LWhereUniqueInput, distinct: [CateogryI18LScalarFieldEnum!], orderBy: [CateogryI18LOrderByWithRelationInput!], skip: Int, take: Int, where: CateogryI18LWhereInput): CateogryI18L
  findFirstItem(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): Item
  findFirstItemI18L(cursor: ItemI18LWhereUniqueInput, distinct: [ItemI18LScalarFieldEnum!], orderBy: [ItemI18LOrderByWithRelationInput!], skip: Int, take: Int, where: ItemI18LWhereInput): ItemI18L
  findFirstMenu(cursor: MenuWhereUniqueInput, distinct: [MenuScalarFieldEnum!], orderBy: [MenuOrderByWithRelationInput!], skip: Int, take: Int, where: MenuWhereInput): Menu
  findFirstOrder(cursor: OrderWhereUniqueInput, distinct: [OrderScalarFieldEnum!], orderBy: [OrderOrderByWithRelationInput!], skip: Int, take: Int, where: OrderWhereInput): Order
  findFirstRestaurant(cursor: RestaurantWhereUniqueInput, distinct: [RestaurantScalarFieldEnum!], orderBy: [RestaurantOrderByWithRelationInput!], skip: Int, take: Int, where: RestaurantWhereInput): Restaurant
  findFirstRestaurantI18L(cursor: RestaurantI18LWhereUniqueInput, distinct: [RestaurantI18LScalarFieldEnum!], orderBy: [RestaurantI18LOrderByWithRelationInput!], skip: Int, take: Int, where: RestaurantI18LWhereInput): RestaurantI18L
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  groupByCateogry(by: [CateogryScalarFieldEnum!]!, having: CateogryScalarWhereWithAggregatesInput, orderBy: [CateogryOrderByWithAggregationInput!], skip: Int, take: Int, where: CateogryWhereInput): [CateogryGroupBy!]!
  groupByCateogryI18L(by: [CateogryI18LScalarFieldEnum!]!, having: CateogryI18LScalarWhereWithAggregatesInput, orderBy: [CateogryI18LOrderByWithAggregationInput!], skip: Int, take: Int, where: CateogryI18LWhereInput): [CateogryI18LGroupBy!]!
  groupByItem(by: [ItemScalarFieldEnum!]!, having: ItemScalarWhereWithAggregatesInput, orderBy: [ItemOrderByWithAggregationInput!], skip: Int, take: Int, where: ItemWhereInput): [ItemGroupBy!]!
  groupByItemI18L(by: [ItemI18LScalarFieldEnum!]!, having: ItemI18LScalarWhereWithAggregatesInput, orderBy: [ItemI18LOrderByWithAggregationInput!], skip: Int, take: Int, where: ItemI18LWhereInput): [ItemI18LGroupBy!]!
  groupByMenu(by: [MenuScalarFieldEnum!]!, having: MenuScalarWhereWithAggregatesInput, orderBy: [MenuOrderByWithAggregationInput!], skip: Int, take: Int, where: MenuWhereInput): [MenuGroupBy!]!
  groupByOrder(by: [OrderScalarFieldEnum!]!, having: OrderScalarWhereWithAggregatesInput, orderBy: [OrderOrderByWithAggregationInput!], skip: Int, take: Int, where: OrderWhereInput): [OrderGroupBy!]!
  groupByRestaurant(by: [RestaurantScalarFieldEnum!]!, having: RestaurantScalarWhereWithAggregatesInput, orderBy: [RestaurantOrderByWithAggregationInput!], skip: Int, take: Int, where: RestaurantWhereInput): [RestaurantGroupBy!]!
  groupByRestaurantI18L(by: [RestaurantI18LScalarFieldEnum!]!, having: RestaurantI18LScalarWhereWithAggregatesInput, orderBy: [RestaurantI18LOrderByWithAggregationInput!], skip: Int, take: Int, where: RestaurantI18LWhereInput): [RestaurantI18LGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  item(where: ItemWhereUniqueInput!): Item
  itemI18L(where: ItemI18LWhereUniqueInput!): ItemI18L
  itemI18LS(cursor: ItemI18LWhereUniqueInput, distinct: [ItemI18LScalarFieldEnum!], orderBy: [ItemI18LOrderByWithRelationInput!], skip: Int, take: Int, where: ItemI18LWhereInput): [ItemI18L!]!
  items(cursor: ItemWhereUniqueInput, distinct: [ItemScalarFieldEnum!], orderBy: [ItemOrderByWithRelationInput!], skip: Int, take: Int, where: ItemWhereInput): [Item!]!
  menu(where: MenuWhereUniqueInput!): Menu
  menus(cursor: MenuWhereUniqueInput, distinct: [MenuScalarFieldEnum!], orderBy: [MenuOrderByWithRelationInput!], skip: Int, take: Int, where: MenuWhereInput): [Menu!]!
  order(where: OrderWhereUniqueInput!): Order
  orders(cursor: OrderWhereUniqueInput, distinct: [OrderScalarFieldEnum!], orderBy: [OrderOrderByWithRelationInput!], skip: Int, take: Int, where: OrderWhereInput): [Order!]!
  restaurant(where: RestaurantWhereUniqueInput!): Restaurant
  restaurantI18L(where: RestaurantI18LWhereUniqueInput!): RestaurantI18L
  restaurantI18LS(cursor: RestaurantI18LWhereUniqueInput, distinct: [RestaurantI18LScalarFieldEnum!], orderBy: [RestaurantI18LOrderByWithRelationInput!], skip: Int, take: Int, where: RestaurantI18LWhereInput): [RestaurantI18L!]!
  restaurants(cursor: RestaurantWhereUniqueInput, distinct: [RestaurantScalarFieldEnum!], orderBy: [RestaurantOrderByWithRelationInput!], skip: Int, take: Int, where: RestaurantWhereInput): [Restaurant!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Restaurant {
  _count: RestaurantCount
  content(cursor: RestaurantI18LWhereUniqueInput, distinct: [RestaurantI18LScalarFieldEnum!], orderBy: [RestaurantI18LOrderByWithRelationInput!], skip: Int, take: Int, where: RestaurantI18LWhereInput): [RestaurantI18L!]!
  createdAt: DateTime!
  id: Int!
  identifier: String!
  logo: String!
  menu: Menu
  order(cursor: OrderWhereUniqueInput, distinct: [OrderScalarFieldEnum!], orderBy: [OrderOrderByWithRelationInput!], skip: Int, take: Int, where: OrderWhereInput): [Order!]!
  slug: String!
  updatedAt: DateTime!
}

type RestaurantAvgAggregate {
  id: Float
}

input RestaurantAvgOrderByAggregateInput {
  id: SortOrder
}

type RestaurantCount {
  content: Int!
  order: Int!
}

type RestaurantCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  identifier: Int!
  logo: Int!
  slug: Int!
  updatedAt: Int!
}

input RestaurantCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  logo: SortOrder
  slug: SortOrder
  updatedAt: SortOrder
}

input RestaurantCreateInput {
  content: RestaurantI18LCreateNestedManyWithoutRestaurantInput
  createdAt: DateTime
  identifier: String!
  logo: String!
  menu: MenuCreateNestedOneWithoutRestaurantInput
  order: OrderCreateNestedManyWithoutRestaurantInput
  slug: String!
  updatedAt: DateTime
}

input RestaurantCreateManyInput {
  createdAt: DateTime
  id: Int
  identifier: String!
  logo: String!
  slug: String!
  updatedAt: DateTime
}

input RestaurantCreateNestedOneWithoutContentInput {
  connect: RestaurantWhereUniqueInput
  connectOrCreate: RestaurantCreateOrConnectWithoutContentInput
  create: RestaurantCreateWithoutContentInput
}

input RestaurantCreateNestedOneWithoutMenuInput {
  connect: RestaurantWhereUniqueInput
  connectOrCreate: RestaurantCreateOrConnectWithoutMenuInput
  create: RestaurantCreateWithoutMenuInput
}

input RestaurantCreateNestedOneWithoutOrderInput {
  connect: RestaurantWhereUniqueInput
  connectOrCreate: RestaurantCreateOrConnectWithoutOrderInput
  create: RestaurantCreateWithoutOrderInput
}

input RestaurantCreateOrConnectWithoutContentInput {
  create: RestaurantCreateWithoutContentInput!
  where: RestaurantWhereUniqueInput!
}

input RestaurantCreateOrConnectWithoutMenuInput {
  create: RestaurantCreateWithoutMenuInput!
  where: RestaurantWhereUniqueInput!
}

input RestaurantCreateOrConnectWithoutOrderInput {
  create: RestaurantCreateWithoutOrderInput!
  where: RestaurantWhereUniqueInput!
}

input RestaurantCreateWithoutContentInput {
  createdAt: DateTime
  identifier: String!
  logo: String!
  menu: MenuCreateNestedOneWithoutRestaurantInput
  order: OrderCreateNestedManyWithoutRestaurantInput
  slug: String!
  updatedAt: DateTime
}

input RestaurantCreateWithoutMenuInput {
  content: RestaurantI18LCreateNestedManyWithoutRestaurantInput
  createdAt: DateTime
  identifier: String!
  logo: String!
  order: OrderCreateNestedManyWithoutRestaurantInput
  slug: String!
  updatedAt: DateTime
}

input RestaurantCreateWithoutOrderInput {
  content: RestaurantI18LCreateNestedManyWithoutRestaurantInput
  createdAt: DateTime
  identifier: String!
  logo: String!
  menu: MenuCreateNestedOneWithoutRestaurantInput
  slug: String!
  updatedAt: DateTime
}

type RestaurantGroupBy {
  _avg: RestaurantAvgAggregate
  _count: RestaurantCountAggregate
  _max: RestaurantMaxAggregate
  _min: RestaurantMinAggregate
  _sum: RestaurantSumAggregate
  createdAt: DateTime!
  id: Int!
  identifier: String!
  logo: String!
  slug: String!
  updatedAt: DateTime!
}

type RestaurantI18L {
  id: Int!
  locale: Locale!
  name: String!
  restaurant: Restaurant!
  restaurantId: Int!
}

type RestaurantI18LAvgAggregate {
  id: Float
  restaurantId: Float
}

input RestaurantI18LAvgOrderByAggregateInput {
  id: SortOrder
  restaurantId: SortOrder
}

type RestaurantI18LCountAggregate {
  _all: Int!
  id: Int!
  locale: Int!
  name: Int!
  restaurantId: Int!
}

input RestaurantI18LCountOrderByAggregateInput {
  id: SortOrder
  locale: SortOrder
  name: SortOrder
  restaurantId: SortOrder
}

input RestaurantI18LCreateInput {
  locale: Locale!
  name: String!
  restaurant: RestaurantCreateNestedOneWithoutContentInput!
}

input RestaurantI18LCreateManyInput {
  id: Int
  locale: Locale!
  name: String!
  restaurantId: Int!
}

input RestaurantI18LCreateManyRestaurantInput {
  id: Int
  locale: Locale!
  name: String!
}

input RestaurantI18LCreateManyRestaurantInputEnvelope {
  data: [RestaurantI18LCreateManyRestaurantInput!]!
  skipDuplicates: Boolean
}

input RestaurantI18LCreateNestedManyWithoutRestaurantInput {
  connect: [RestaurantI18LWhereUniqueInput!]
  connectOrCreate: [RestaurantI18LCreateOrConnectWithoutRestaurantInput!]
  create: [RestaurantI18LCreateWithoutRestaurantInput!]
  createMany: RestaurantI18LCreateManyRestaurantInputEnvelope
}

input RestaurantI18LCreateOrConnectWithoutRestaurantInput {
  create: RestaurantI18LCreateWithoutRestaurantInput!
  where: RestaurantI18LWhereUniqueInput!
}

input RestaurantI18LCreateWithoutRestaurantInput {
  locale: Locale!
  name: String!
}

type RestaurantI18LGroupBy {
  _avg: RestaurantI18LAvgAggregate
  _count: RestaurantI18LCountAggregate
  _max: RestaurantI18LMaxAggregate
  _min: RestaurantI18LMinAggregate
  _sum: RestaurantI18LSumAggregate
  id: Int!
  locale: Locale!
  name: String!
  restaurantId: Int!
}

input RestaurantI18LListRelationFilter {
  every: RestaurantI18LWhereInput
  none: RestaurantI18LWhereInput
  some: RestaurantI18LWhereInput
}

type RestaurantI18LMaxAggregate {
  id: Int
  locale: Locale
  name: String
  restaurantId: Int
}

input RestaurantI18LMaxOrderByAggregateInput {
  id: SortOrder
  locale: SortOrder
  name: SortOrder
  restaurantId: SortOrder
}

type RestaurantI18LMinAggregate {
  id: Int
  locale: Locale
  name: String
  restaurantId: Int
}

input RestaurantI18LMinOrderByAggregateInput {
  id: SortOrder
  locale: SortOrder
  name: SortOrder
  restaurantId: SortOrder
}

input RestaurantI18LOrderByRelationAggregateInput {
  _count: SortOrder
}

input RestaurantI18LOrderByWithAggregationInput {
  _avg: RestaurantI18LAvgOrderByAggregateInput
  _count: RestaurantI18LCountOrderByAggregateInput
  _max: RestaurantI18LMaxOrderByAggregateInput
  _min: RestaurantI18LMinOrderByAggregateInput
  _sum: RestaurantI18LSumOrderByAggregateInput
  id: SortOrder
  locale: SortOrder
  name: SortOrder
  restaurantId: SortOrder
}

input RestaurantI18LOrderByWithRelationInput {
  id: SortOrder
  locale: SortOrder
  name: SortOrder
  restaurant: RestaurantOrderByWithRelationInput
  restaurantId: SortOrder
}

enum RestaurantI18LScalarFieldEnum {
  id
  locale
  name
  restaurantId
}

input RestaurantI18LScalarWhereInput {
  AND: [RestaurantI18LScalarWhereInput!]
  NOT: [RestaurantI18LScalarWhereInput!]
  OR: [RestaurantI18LScalarWhereInput!]
  id: IntFilter
  locale: EnumLocaleFilter
  name: StringFilter
  restaurantId: IntFilter
}

input RestaurantI18LScalarWhereWithAggregatesInput {
  AND: [RestaurantI18LScalarWhereWithAggregatesInput!]
  NOT: [RestaurantI18LScalarWhereWithAggregatesInput!]
  OR: [RestaurantI18LScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  locale: EnumLocaleWithAggregatesFilter
  name: StringWithAggregatesFilter
  restaurantId: IntWithAggregatesFilter
}

type RestaurantI18LSumAggregate {
  id: Int
  restaurantId: Int
}

input RestaurantI18LSumOrderByAggregateInput {
  id: SortOrder
  restaurantId: SortOrder
}

input RestaurantI18LUpdateInput {
  locale: EnumLocaleFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  restaurant: RestaurantUpdateOneRequiredWithoutContentInput
}

input RestaurantI18LUpdateManyMutationInput {
  locale: EnumLocaleFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input RestaurantI18LUpdateManyWithWhereWithoutRestaurantInput {
  data: RestaurantI18LUpdateManyMutationInput!
  where: RestaurantI18LScalarWhereInput!
}

input RestaurantI18LUpdateManyWithoutRestaurantInput {
  connect: [RestaurantI18LWhereUniqueInput!]
  connectOrCreate: [RestaurantI18LCreateOrConnectWithoutRestaurantInput!]
  create: [RestaurantI18LCreateWithoutRestaurantInput!]
  createMany: RestaurantI18LCreateManyRestaurantInputEnvelope
  delete: [RestaurantI18LWhereUniqueInput!]
  deleteMany: [RestaurantI18LScalarWhereInput!]
  disconnect: [RestaurantI18LWhereUniqueInput!]
  set: [RestaurantI18LWhereUniqueInput!]
  update: [RestaurantI18LUpdateWithWhereUniqueWithoutRestaurantInput!]
  updateMany: [RestaurantI18LUpdateManyWithWhereWithoutRestaurantInput!]
  upsert: [RestaurantI18LUpsertWithWhereUniqueWithoutRestaurantInput!]
}

input RestaurantI18LUpdateWithWhereUniqueWithoutRestaurantInput {
  data: RestaurantI18LUpdateWithoutRestaurantInput!
  where: RestaurantI18LWhereUniqueInput!
}

input RestaurantI18LUpdateWithoutRestaurantInput {
  locale: EnumLocaleFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input RestaurantI18LUpsertWithWhereUniqueWithoutRestaurantInput {
  create: RestaurantI18LCreateWithoutRestaurantInput!
  update: RestaurantI18LUpdateWithoutRestaurantInput!
  where: RestaurantI18LWhereUniqueInput!
}

input RestaurantI18LWhereInput {
  AND: [RestaurantI18LWhereInput!]
  NOT: [RestaurantI18LWhereInput!]
  OR: [RestaurantI18LWhereInput!]
  id: IntFilter
  locale: EnumLocaleFilter
  name: StringFilter
  restaurant: RestaurantRelationFilter
  restaurantId: IntFilter
}

input RestaurantI18LWhereUniqueInput {
  id: Int
}

type RestaurantMaxAggregate {
  createdAt: DateTime
  id: Int
  identifier: String
  logo: String
  slug: String
  updatedAt: DateTime
}

input RestaurantMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  logo: SortOrder
  slug: SortOrder
  updatedAt: SortOrder
}

type RestaurantMinAggregate {
  createdAt: DateTime
  id: Int
  identifier: String
  logo: String
  slug: String
  updatedAt: DateTime
}

input RestaurantMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  logo: SortOrder
  slug: SortOrder
  updatedAt: SortOrder
}

input RestaurantOrderByWithAggregationInput {
  _avg: RestaurantAvgOrderByAggregateInput
  _count: RestaurantCountOrderByAggregateInput
  _max: RestaurantMaxOrderByAggregateInput
  _min: RestaurantMinOrderByAggregateInput
  _sum: RestaurantSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  logo: SortOrder
  slug: SortOrder
  updatedAt: SortOrder
}

input RestaurantOrderByWithRelationInput {
  content: RestaurantI18LOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  identifier: SortOrder
  logo: SortOrder
  menu: MenuOrderByWithRelationInput
  order: OrderOrderByRelationAggregateInput
  slug: SortOrder
  updatedAt: SortOrder
}

input RestaurantRelationFilter {
  is: RestaurantWhereInput
  isNot: RestaurantWhereInput
}

enum RestaurantScalarFieldEnum {
  createdAt
  id
  identifier
  logo
  slug
  updatedAt
}

input RestaurantScalarWhereWithAggregatesInput {
  AND: [RestaurantScalarWhereWithAggregatesInput!]
  NOT: [RestaurantScalarWhereWithAggregatesInput!]
  OR: [RestaurantScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  identifier: StringWithAggregatesFilter
  logo: StringWithAggregatesFilter
  slug: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type RestaurantSumAggregate {
  id: Int
}

input RestaurantSumOrderByAggregateInput {
  id: SortOrder
}

input RestaurantUpdateInput {
  content: RestaurantI18LUpdateManyWithoutRestaurantInput
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  logo: StringFieldUpdateOperationsInput
  menu: MenuUpdateOneWithoutRestaurantInput
  order: OrderUpdateManyWithoutRestaurantInput
  slug: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RestaurantUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  logo: StringFieldUpdateOperationsInput
  slug: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RestaurantUpdateOneRequiredWithoutContentInput {
  connect: RestaurantWhereUniqueInput
  connectOrCreate: RestaurantCreateOrConnectWithoutContentInput
  create: RestaurantCreateWithoutContentInput
  update: RestaurantUpdateWithoutContentInput
  upsert: RestaurantUpsertWithoutContentInput
}

input RestaurantUpdateOneRequiredWithoutMenuInput {
  connect: RestaurantWhereUniqueInput
  connectOrCreate: RestaurantCreateOrConnectWithoutMenuInput
  create: RestaurantCreateWithoutMenuInput
  update: RestaurantUpdateWithoutMenuInput
  upsert: RestaurantUpsertWithoutMenuInput
}

input RestaurantUpdateOneRequiredWithoutOrderInput {
  connect: RestaurantWhereUniqueInput
  connectOrCreate: RestaurantCreateOrConnectWithoutOrderInput
  create: RestaurantCreateWithoutOrderInput
  update: RestaurantUpdateWithoutOrderInput
  upsert: RestaurantUpsertWithoutOrderInput
}

input RestaurantUpdateWithoutContentInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  logo: StringFieldUpdateOperationsInput
  menu: MenuUpdateOneWithoutRestaurantInput
  order: OrderUpdateManyWithoutRestaurantInput
  slug: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RestaurantUpdateWithoutMenuInput {
  content: RestaurantI18LUpdateManyWithoutRestaurantInput
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  logo: StringFieldUpdateOperationsInput
  order: OrderUpdateManyWithoutRestaurantInput
  slug: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RestaurantUpdateWithoutOrderInput {
  content: RestaurantI18LUpdateManyWithoutRestaurantInput
  createdAt: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  logo: StringFieldUpdateOperationsInput
  menu: MenuUpdateOneWithoutRestaurantInput
  slug: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RestaurantUpsertWithoutContentInput {
  create: RestaurantCreateWithoutContentInput!
  update: RestaurantUpdateWithoutContentInput!
}

input RestaurantUpsertWithoutMenuInput {
  create: RestaurantCreateWithoutMenuInput!
  update: RestaurantUpdateWithoutMenuInput!
}

input RestaurantUpsertWithoutOrderInput {
  create: RestaurantCreateWithoutOrderInput!
  update: RestaurantUpdateWithoutOrderInput!
}

input RestaurantWhereInput {
  AND: [RestaurantWhereInput!]
  NOT: [RestaurantWhereInput!]
  OR: [RestaurantWhereInput!]
  content: RestaurantI18LListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  identifier: StringFilter
  logo: StringFilter
  menu: MenuRelationFilter
  order: OrderListRelationFilter
  slug: StringFilter
  updatedAt: DateTimeFilter
}

input RestaurantWhereUniqueInput {
  id: Int
  identifier: String
  slug: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  email: String!
  id: Int!
  name: String
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCountAggregate {
  _all: Int!
  email: Int!
  id: Int!
  name: Int!
}

input UserCountOrderByAggregateInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserCreateInput {
  email: String!
  name: String
}

input UserCreateManyInput {
  email: String!
  id: Int
  name: String
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  email: String!
  id: Int!
  name: String
}

type UserMaxAggregate {
  email: String
  id: Int
  name: String
}

input UserMaxOrderByAggregateInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

type UserMinAggregate {
  email: String
  id: Int
  name: String
}

input UserMinOrderByAggregateInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

input UserOrderByWithRelationInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
}

enum UserScalarFieldEnum {
  email
  id
  name
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  email: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  email: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  email: StringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: StringFilter
  id: IntFilter
  name: StringNullableFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
